package man;

public interface Map {
    /**
     * Map 解释:查找表,我觉得翻译为映射更好一些
     *
     * 一个对象可以将键映射到值,一个映射不能包含多个键,每个键最多只能映射到一个值
     *
     * 这个借口替代了 Dictionary 类,是一个完全抽象的类,而不是接口
     *
     * 这个 Map 接口提供了3种集合视图,允许将映射的内容看做一组键值集合或者一组键值映射,
     * 有序映射被定义为映射集合视图上的有序迭代器,返回他们.例如像 TreeMap 映射的实现,就利用了这个,
     * 保证了他们特定的顺序,其他像 HashMap 并没有用到
     *
     * 注意: 如果将可变对象用作映射的键那就要非常小心了.
     * 用一种对象在映射里作为键的方式做比较,对象的值改变了,映射的行为也会改变;( affects <tt>equals</tt> comparisons 翻译:影响相等比较)
     * 也有特殊的例子,一个映射是不允许将他自己作为键的;当然,一个映射把它自己作为值是被允许的;
     * 特别注意的是: equals和hashCode方法在这种映射里是不太良好的定义
     *
     * 通常映射的实现应该提供两个标准的构造函数:一个无参构造函数创建一个空映射,一个带单个参数类型的映射,
     * 该映射创建一个带相同键值的映射作为他们的参数;实际上,后者允许用户复制任何映射,生成所需类的等效映射。
     * 并不是强制执行这个建议(正如接口中不包含构造函数),但是所有在jdk中的映射已经实现
     *
     * 烂方法包含在这个接口中,那就是方法修改他们所操作的映射,当然,如果这个映射不支持这个操作,会抛出
     * UnsupportedOperationException的异常,如果是这样,这些方法可能会这样,
     * 如果调取不会影响到这个映射,不会抛出异常.
     * 例如要调用一个不可改变的map的putAll方法,如果这个要叠加的映射为空,就会抛出一个异常,但是这不需要
     *
     * 一些映射的实现在他们的键值上做了限制.例如:一些实现映射实现禁止空键和空值,一些则在他们的键的类型上做了限制,
     * 尝试去插入不合法的键或值就会抛出未捕获的空指针或类型转换异常的异常
     **/

}
